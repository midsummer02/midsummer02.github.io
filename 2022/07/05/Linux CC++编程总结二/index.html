<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"midsummer02.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.12.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="进程">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux C&#x2F;C++编程总结二">
<meta property="og:url" content="https://midsummer02.github.io/2022/07/05/Linux%20CC++%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93%E4%BA%8C/index.html">
<meta property="og:site_name" content="M1DSUMMER&#39;s BLOG">
<meta property="og:description" content="进程">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-05T00:15:16.000Z">
<meta property="article:modified_time" content="2022-08-07T00:43:22.184Z">
<meta property="article:author" content="Sun">
<meta property="article:tag" content="Linux c&#x2F;c++">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://midsummer02.github.io/2022/07/05/Linux%20CC++%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93%E4%BA%8C/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://midsummer02.github.io/2022/07/05/Linux%20CC++%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93%E4%BA%8C/","path":"2022/07/05/Linux CC++编程总结二/","title":"Linux C/C++编程总结二"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Linux C/C++编程总结二 | M1DSUMMER's BLOG</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">M1DSUMMER's BLOG</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">我只是一条咸鱼</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Sun</p>
  <div class="site-description" itemprop="description">学习记录</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://midsummer02.github.io/2022/07/05/Linux%20CC++%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sun">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="M1DSUMMER's BLOG">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Linux C/C++编程总结二 | M1DSUMMER's BLOG">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux C/C++编程总结二
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-05 08:15:16" itemprop="dateCreated datePublished" datetime="2022-07-05T08:15:16+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-08-07 08:43:22" itemprop="dateModified" datetime="2022-08-07T08:43:22+08:00">2022-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">Linux学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">基础知识</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><span id="more"></span>

<h3 id="1-进程的创建与销毁"><a href="#1-进程的创建与销毁" class="headerlink" title="1.进程的创建与销毁"></a>1.进程的创建与销毁</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>	</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//创建线程 返回值：成功：子进程中返回 0，父进程中返回子进程 ID 失败：返回 -1</span></span><br><span class="line"><span class="comment">//进程创建不一定成功，失败的两个主要原因：</span></span><br><span class="line">	<span class="comment">//（1）当前系统的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN</span></span><br><span class="line">	<span class="comment">//（2）系统内存不足，这时 errno 的值被设置为 ENOMEM</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//进程号相关</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="type">void</span>)</span></span>;			  <span class="comment">//返回目前进程的进程识别码</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="type">void</span>)</span></span>;	 	  <span class="comment">//返回父进程标识</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span></span>;	  <span class="comment">//返回组进程标识</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//进程退出	</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exit</span><span class="params">(<span class="type">int</span> status)</span></span>;   <span class="comment">//属于标准库函数</span></span><br><span class="line"><span class="comment">//进程退出	#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);  <span class="comment">//属于系统调用</span></span><br><span class="line"><span class="comment">//参数为 status 返回给父进程的参数(低8位有效)，两个函数的功能相同，库函数不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//进程回收</span></span><br><span class="line"><span class="comment">//头文件	#include &lt;sys/types.h&gt;	#include &lt;wait.h&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">wait</span><span class="params">(<span class="type">int</span> *status)</span></span></span><br><span class="line"><span class="function"><span class="comment">//父进程一旦调用了wait就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。若不执行wait函数则可能会出现父进程结束子进程还在运行的情况，子进程会无法回收变成僵尸进程。</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回值：如果执行成功则返回子进程识别码(PID), 如果有错误发生则返回-1. 失败原因存于errno 中。</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> * status, <span class="type">int</span> options)</span></span>;</span><br><span class="line"><span class="comment">//pid表示要等待的进程</span></span><br><span class="line">	<span class="comment">//pid&lt;-1 等待进程组识别码为pid 绝对值的任何子进程.pid=-1 等待任何子进程, 相当于wait()。</span></span><br><span class="line">	<span class="comment">//pid=0 等待进程组识别码与目前进程相同的任何子进程.pid&gt;0 等待任何子进程识别码为pid 的子进程。</span></span><br><span class="line"><span class="comment">//options可以为0 或下面的 OR 组合</span></span><br><span class="line">	<span class="comment">//WIFEXITED(status) 非0，进程正常退出</span></span><br><span class="line">	<span class="comment">//WEXITSTATUS(status) 如果上宏为真，获取进程退出的状态（exit的参数）</span></span><br><span class="line">    <span class="comment">//WIFSIGNALED(status) 非0，进程异常终止</span></span><br><span class="line">    <span class="comment">//WTERMSIG(status) 如果上宏为真，获取使进程终止的信号编号</span></span><br><span class="line">    <span class="comment">//WIFSTOPPED(status) 非0，进程处于暂停状态</span></span><br><span class="line">    <span class="comment">//WSTOPSIG(status) 如果上宏为真，获取使进程暂停的信号的编号</span></span><br><span class="line">    <span class="comment">//WIFCONTINUED(status) 非0，进程暂停后已经继续运行</span></span><br></pre></td></tr></table></figure>

<h3 id="2-线程同步："><a href="#2-线程同步：" class="headerlink" title="2.线程同步："></a>2.线程同步：</h3><h4 id="（1）匿名管道pipe："><a href="#（1）匿名管道pipe：" class="headerlink" title="（1）匿名管道pipe："></a>（1）匿名管道pipe：</h4><p>pipe提供两个文件描述符来操作管道。其中一个对管道进行写操作，另一个对管道进行读操作。对管道的读写与一般的IO系统函数一致，使用write()函数写入数据，使用read()读出数据。匿名管道没有文件实体，本质是一个在内核内存中维护的缓冲器，其内数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="comment">//pipefd[0] 对应的是管道的读端；pipefd[1] 对应的是管道的写端</span></span><br><span class="line"><span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">pipe</span>(pipefd);</span><br><span class="line"><span class="comment">//父进程读取</span></span><br><span class="line"><span class="built_in">close</span>(pipefd[<span class="number">1</span>]);		<span class="comment">//关闭写端</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;	</span><br><span class="line"><span class="built_in">read</span>(pipefd[<span class="number">0</span>], buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"><span class="comment">//子进程</span></span><br><span class="line"><span class="built_in">close</span>(pipefd[<span class="number">0</span>]);		<span class="comment">//关闭读端</span></span><br><span class="line"><span class="type">char</span> * str = <span class="string">&quot;hello,i am child&quot;</span>;</span><br><span class="line"><span class="built_in">write</span>(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br></pre></td></tr></table></figure>

<h4 id="（2）有名管道FIFO："><a href="#（2）有名管道FIFO：" class="headerlink" title="（2）有名管道FIFO："></a>（2）有名管道FIFO：</h4><p>有名管道提供了一个路径名与之关联，以 FIFO 的文件形式存 在于文件系统中，并且其打开方式与打开一个普通文件是一样的。与匿名管道pipe只能用于亲缘关系的进程间通信不同， 即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="comment">//通过函数创建有名管道</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<p>一旦使用 mkfifo 创建了一个 FIFO，就可以使用 open 打开它，常见的文件I&#x2F;O 函数都可用于 FIFO。如： close、read、write、unlink 等。 FIFO 就像其名字，遵循先进先出原则，对管道及 FIFO 的读总是从开始处返回数据，对它们的写则把数据添加到末尾。FIFO不支持诸如 lseek() 等文件定位操作。</p>
<h4 id="（3）内存映射："><a href="#（3）内存映射：" class="headerlink" title="（3）内存映射："></a>（3）内存映射：</h4><p>内存映射是一种内存映射技术。将磁盘文件的数据映射到内存，使用户通过修改内存就能修改磁盘文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个文件或者设备的数据映射到内存中</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="comment">//- void *addr: NULL, 由内核指定</span></span><br><span class="line"><span class="comment">//- length : 要映射的数据的长度，一般使用文件的长度。</span></span><br><span class="line"><span class="comment">//- prot : 对申请的内存映射区的操作权限</span></span><br><span class="line">      <span class="comment">//-PROT_EXEC ：可执行的权限	-PROT_READ ：读权限</span></span><br><span class="line">      <span class="comment">//-PROT_WRITE ：写权限	-PROT_NONE ：没有权限</span></span><br><span class="line">      <span class="comment">//要操作映射内存，必须要有读的权限。</span></span><br><span class="line"><span class="comment">//- flags :</span></span><br><span class="line">      <span class="comment">//- MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项</span></span><br><span class="line">      <span class="comment">//- MAP_PRIVATE ：不同步，内存映射区数据改变后，不修改原来文件，而是重新创建一个新的文件。</span></span><br><span class="line"><span class="comment">//- fd: 需要映射的那个文件的文件描述符</span></span><br><span class="line">      <span class="comment">//- 通过open得到，open的是一个磁盘文件</span></span><br><span class="line">      <span class="comment">//- 注意：文件的大小不能为0，open指定的权限不能和prot参数有冲突。</span></span><br><span class="line"><span class="comment">//- 返回值：成功返回创建的内存的首地址，失败返回MAP_FAILED，(void *) -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存映射</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在内存映射中，参数flags除了上述两种宏定义外，还有一个宏定义为MAP_ANONYMOUS，表示匿名映射，此时的文件映射会将一个内核创建的全为进制零文件映射到虚拟内存中，不需要真正的文件实体。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建匿名内存映射区</span></span><br><span class="line"><span class="type">int</span> len = <span class="number">4096</span>;</span><br><span class="line"><span class="type">void</span> * ptr = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *) ptr, <span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">    <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 子进程</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span> *)ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">munmap</span>(ptr, len);		<span class="comment">//释放内存映射区</span></span><br></pre></td></tr></table></figure>

<h4 id="（4）信号："><a href="#（4）信号：" class="headerlink" title="（4）信号："></a>（4）信号：</h4><p>信号是事件发生时对进程的通知机制，信号可以导致⼀个正在运⾏ 的进程被另⼀个正在运⾏的异步进程中断，转⽽处理某⼀个突发事件。信号可以被理解为软件中断，是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。其工作流程为：信号产生—&gt;信号的注册和注销—&gt;执行信号处理函数。</p>
<p><strong>信号产生函数：</strong>kill、raise、abort、alarm、setitimer</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给指定进程发送指定信号(不⼀定杀死).</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span></span>;</span><br><span class="line"><span class="comment">//pid &gt; 0: 将信号传送给进程 ID 为pid的进程; pid = 0 : 将信号传送给当前进程所在进程组中的所有进程;</span></span><br><span class="line"><span class="comment">//pid = -1 : 将信号传送给系统内所有的进程; pid &lt; -1 : 将信号传给指定进程组的所有进程.</span></span><br><span class="line"><span class="comment">//sig 为信号的编号，这⾥可以填数字编号，也可以填信号的宏定义.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给当前进程发送指定信号(⾃⼰给⾃⼰发)，等价于 kill(getpid(), sig).</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">raise</span><span class="params">(<span class="type">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//给当前进程发送异常终⽌信号 6) SIGABRT，并产⽣core⽂件，等价于kill(getpid(), SIGABRT).</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">abort</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送14）SIGALRM信号。</span></span><br><span class="line"><span class="comment">//进程收到该信号，默认动作终⽌。每个进程都有且只有唯⼀的⼀个定时器;</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置定时器函数。 可代替alarm函数。精度微秒us，可以实现周期定时。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">itimerval</span> &#123;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">timerval</span> it_interval; <span class="comment">// 闹钟触发周期</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">timerval</span> it_value; <span class="comment">// 闹钟触发时间</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> &#123;</span><br><span class="line"> <span class="type">long</span> tv_sec; <span class="comment">// 秒</span></span><br><span class="line"> <span class="type">long</span> tv_usec; <span class="comment">// 微秒</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//which 指定定时⽅式:</span></span><br><span class="line">	<span class="comment">//⾃然定时：ITIMER_REAL → 14）SIGALRM计算⾃然时间;</span></span><br><span class="line">	<span class="comment">//虚拟空间计时(⽤户空间)：ITIMER_VIRTUAL → 26）SIGVTALRM 只计算进程占⽤cpu的时间;</span></span><br><span class="line"><span class="comment">//new_value 负责设定timeout时间.</span></span><br><span class="line"><span class="comment">//old_value 存放旧的timeout值，⼀般指定为NULL.</span></span><br><span class="line"><span class="comment">//返回值 成功: 0; 失败: -1.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *new_value, <span class="keyword">struct</span> itimerval *old_value)</span></span>;</span><br><span class="line"><span class="comment">// itimerval.it_value： 设定第⼀次执⾏function所延迟的秒数</span></span><br><span class="line"><span class="comment">// itimerval.it_interval： 设定以后每⼏秒执⾏function</span></span><br></pre></td></tr></table></figure>

<p><strong>信号集</strong>：一组信号的集合，记录了集合中每一个信号的属性。由<strong>sigset_t数据类型</strong>来存储，其本质上是位图，用0和1代表该位信号是否阻塞或者是否为未决状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *set)</span></span>; <span class="comment">// 将set集合置空</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *set)</span></span>; <span class="comment">// 将所有信号加⼊set集合</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *set, <span class="type">int</span> signo)</span></span>; <span class="comment">// 将signo信号加⼊到set集合</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *set, <span class="type">int</span> signo)</span></span>; <span class="comment">// 从set集合中移除signo信号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *set, <span class="type">int</span> signo)</span></span>; <span class="comment">// 判断信号是否存在</span></span><br></pre></td></tr></table></figure>

<p>当一个信号产生并被捕获后，和阻塞信号集中的标志位进行查询。若没有阻塞，这个信号就被处理；若阻塞，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理。通常使用sigprocmask函数 设置阻塞集：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查或修改信号阻塞集，根据 how 指定的⽅法对进程的阻塞集合进⾏修改，</span></span><br><span class="line"><span class="comment">//新的信号阻塞集由 set 指定，⽽原先的信号阻塞集合由 oldset 保存.</span></span><br><span class="line"><span class="comment">// how 信号阻塞集合的修改⽅法，有 3 种情况:</span></span><br><span class="line">	<span class="comment">//SIG_BLOCK：向信号阻塞集合中添加 set 信号集，</span></span><br><span class="line">	<span class="comment">//新的信号掩码是set和旧信号掩码的并集。相当于 mask = mask|set;</span></span><br><span class="line">	<span class="comment">//SIG_UNBLOCK：从信号阻塞集合中删除 set 信号集，</span></span><br><span class="line">	<span class="comment">//从当前信号掩码中去除 set 中的信号。相当于 mask = mask &amp; ~ set;</span></span><br><span class="line">	<span class="comment">//SIG_SETMASK：将信号阻塞集合设为 set 信号集，</span></span><br><span class="line">	<span class="comment">//相当于原来信号阻塞集的内容清空，然后按照 set 中的信号᯿新设置信号阻塞集。相当于mask = set.</span></span><br><span class="line"><span class="comment">//set 要操作的信号集地址,若set为 NULL，则不改变信号阻塞集合，函数只把当前信号阻塞集合保存到oldset中。</span></span><br><span class="line"><span class="comment">//oldset 保存原先信号阻塞集地址。</span></span><br><span class="line"><span class="comment">//返回值 成功: 0; 失败: -1，失败时错误代码只可能是 EINVAL，表示参数 how 不合法。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *set, <span class="type">sigset_t</span> *oldset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取当前进程的未决信号集。</span></span><br><span class="line"><span class="comment">//set 未决信号集,返回值：成功: 0; 失败: -1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigpending</span><span class="params">(<span class="type">sigset_t</span> *set)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>信号的捕捉和处理：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> &#123;</span><br><span class="line"> <span class="built_in">void</span>(*sa_handler)(<span class="type">int</span>); <span class="comment">//旧的信号处理函数指针</span></span><br><span class="line"> <span class="built_in">void</span>(*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *); <span class="comment">//新的信号处理函数指针</span></span><br><span class="line"> <span class="type">sigset_t</span> sa_mask; <span class="comment">//信号阻塞集</span></span><br><span class="line"> <span class="type">int</span> sa_flags; <span class="comment">//信号处理的⽅式</span></span><br><span class="line"> <span class="built_in">void</span>(*sa_restorer)(<span class="type">void</span>); <span class="comment">//已弃⽤</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//处理时使用临时信号阻塞集，之后恢复</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查或修改指定信号的设置（或同时执⾏这两种操作）。</span></span><br><span class="line"><span class="comment">//signum 要操作的信号。</span></span><br><span class="line"><span class="comment">//act 要设置的对信号的新处理⽅式（传⼊参数）。</span></span><br><span class="line"><span class="comment">//oldact：原来对信号的处理⽅式（传出参数）。</span></span><br><span class="line">	<span class="comment">//如果 act 指针⾮空，则要改变指定信号的处理⽅式（设置），</span></span><br><span class="line">	<span class="comment">//如果 oldact 指针⾮空，则系统将此前指定信号的处理⽅式存⼊ oldact。</span></span><br><span class="line"><span class="comment">//返回值 成功: 0; 失败: -1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>一些信号的属性和对应事件：</strong></p>
<table>
<thead>
<tr>
<th>编号</th>
<th>信号宏定义</th>
<th>对应事件</th>
<th>默认动作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIGHUP</td>
<td>用户退出shell时，由该shell启动的所有进程将收到这个信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>当用户按下了&lt;Ctrl+C&gt;组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>3</td>
<td>SIGQUIT</td>
<td>用户按下&lt;Ctrl+&gt;组合键时产生该信号，用户终端向正在运 行中的由该终端启动的程序发出些信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>无条件终止进程。该信号不能被忽略，处理和阻塞</td>
<td>终止进程，可以杀死任何进程</td>
</tr>
<tr>
<td>11</td>
<td>SIGSEGV</td>
<td>指示进程进行了无效内存访问(段错误)</td>
<td>终止进程并产生 core文件</td>
</tr>
<tr>
<td>13</td>
<td><strong>SIGPIPE</strong></td>
<td>对一个对端已经关闭的socket调用两次write, 第二次将会生成<strong>SIGPIPE</strong>信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>17</td>
<td><strong>SIGCHLD</strong></td>
<td><strong>子进程结束时，父进程会收到这个信号</strong></td>
<td><strong>忽略这个信号</strong></td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>如果进程已停止，则使其继续运行</td>
<td>继续&#x2F;忽略</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>停止进程的执行。信号不能被忽略，处理和阻塞</td>
<td>终止进程</td>
</tr>
<tr>
<td>34 ~ 64</td>
<td>SIGRTMIN ～ SIGRTMAX</td>
<td>LINUX的实时信号，它们没有固定的含义（可以由用户自 定义）</td>
<td>终止进程</td>
</tr>
</tbody></table>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux-c-c/" rel="tag"># Linux c/c++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/06/30/Linux%20CC++%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%9A/" rel="prev" title="Linux C/C++编程总结一">
                  <i class="fa fa-chevron-left"></i> Linux C/C++编程总结一
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/07/08/LinuxCC++%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93%E4%B8%89/" rel="next" title="Linux CC++编程总结三">
                  Linux CC++编程总结三 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sun</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
